<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Merrick&#39;s Blog</title>
  <subtitle>Merrick is blogging about life, tech and music.</subtitle>
  <link href="https://lutaonan.com/rss.xml" rel="self"/>
  <link href="https://lutaonan.com/"/>
  <updated>2023-07-06T00:00:00Z</updated>
  <id>https://lutaonan.com/</id>
  <author>
    <name>Merrick</name>
  </author>
  
  <entry>
    <title>大三下学期的体验与感悟</title>
    <link href="https://lutaonan.com/blog/express-my-life-Second-semester-of-junior-year/"/>
    <updated>2023-07-06T00:00:00Z</updated>
    <id>https://lutaonan.com/blog/express-my-life-Second-semester-of-junior-year/</id>
    <content type="html">&lt;p&gt;大三下学期，是实习的关键时期。但是自从拿到了 offer 之后，就感觉到没有继续努力的动力了，但我仍然很清楚，程序员就是一个终生学习的岗位。尽管知道，但是人总是怠惰的，短期目标的消失，长期目标就失去了连接，自然而然也没有了动力去努力下去。&lt;/p&gt;
&lt;p&gt;这也是当然的，因为长期目标的存在，空虚感就随着短期的懈怠而涌现。&lt;/p&gt;
&lt;p&gt;Be aware, Be free.&lt;/p&gt;
&lt;p&gt;我很喜欢这句名言。你察觉到了，你就获得了自由。所以我打心底地认为，如果我就这样懈怠到了实习，我感觉我之后的道路都会被牵着走，很快就会迎接终点。&lt;/p&gt;
&lt;p&gt;在我写博客的同时，我也在逐渐地理清自己的思路和需求。就像写代码时逐渐拨云见日的感觉。但我在目前的节点，又想继续全栈的道路，又想加深英语、日语的学习。但精力是有限的，我还是先巩固技术，再去学习语言，因为我真的很想去看看外面的世界。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;这一段就是我目前与学校间的插曲了。&lt;/p&gt;
&lt;p&gt;因为在 2019 级，学校的就业率太难看了，所以学校打算大四上学期，强制要求学生去参加校企之间合作的实习。这简直糟透了。对于像我这种有 offer 的人，大四就直接失去了实习和秋招的机会。校方的强硬态度，也是让我看到了学校的颓势。大连交通大学，它确实是在衰落了。&lt;/p&gt;
&lt;p&gt;学校在执行这种专横的抉择的同时，还封住了所有人的嘴。我实在很难想明白，如果校方真的是为了我们好，为什么还会堵住我们的声音呢？&lt;/p&gt;
&lt;p&gt;也可能是周围的环境逐渐地浮躁起来了，我也有些浮躁了。但是跟上面我所提到的，察觉即自由。如果这是必然发生的事情，我也只能接收，但我还是会尽量地去争取。我也相信，实力强大的人，在那里都有他能展示的机会。&lt;/p&gt;
&lt;p&gt;随遇而安是自我安慰，也是人生哲理。如果未来的自己还是这样的弱小，那么再愚蠢的规定，也只能乖乖接受。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>做了 6 年程序员，我学到的 10 条经验</title>
    <link href="https://lutaonan.com/blog/things-i-learnt-after-6-years-as-software-engineer/"/>
    <updated>2022-09-20T00:00:00Z</updated>
    <id>https://lutaonan.com/blog/things-i-learnt-after-6-years-as-software-engineer/</id>
    <content type="html">&lt;p&gt;索引&lt;/p&gt;
&lt;nav class=&quot;table-of-contents&quot;&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/things-i-learnt-after-6-years-as-software-engineer/#%E4%BF%9D%E6%8C%81%E4%B8%80%E9%A2%97%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84%E5%BF%83&quot;&gt;保持一颗解决问题的心&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/things-i-learnt-after-6-years-as-software-engineer/#%E4%BA%86%E8%A7%A3%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7&quot;&gt;了解你的用户&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/things-i-learnt-after-6-years-as-software-engineer/#%E4%B8%8D%E8%A6%81%E6%8B%BF%E8%87%AA%E5%B7%B1%E7%9A%84%E5%B0%BA%E5%AD%90%E5%8E%BB%E5%BA%A6%E9%87%8F%E5%88%AB%E4%BA%BA&quot;&gt;不要拿自己的尺子去度量别人&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/things-i-learnt-after-6-years-as-software-engineer/#%E4%BF%9D%E6%8C%81%E5%AD%A6%E4%B9%A0%E3%80%81be-open-mind&quot;&gt;保持学习、be open-mind&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/things-i-learnt-after-6-years-as-software-engineer/#%E6%83%B3%E6%B8%85%E6%A5%9A%EF%BC%8C%E5%86%8D%E4%B8%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81&quot;&gt;想清楚，再下手写代码&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/things-i-learnt-after-6-years-as-software-engineer/#%E6%95%AC%E7%95%8F%E7%94%A8%E6%88%B7&quot;&gt;敬畏用户&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/things-i-learnt-after-6-years-as-software-engineer/#%E8%B7%A8%E5%9B%A2%E9%98%9F%E5%90%88%E4%BD%9C%E6%98%AF%E5%88%A9%E7%9B%8A%E4%BA%A4%E6%8D%A2&quot;&gt;跨团队合作是利益交换&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/things-i-learnt-after-6-years-as-software-engineer/#%E7%94%A8%E5%88%AB%E4%BA%BA%E7%9A%84%E8%AF%AD%E8%A8%80%E4%BA%A4%E6%B5%81%EF%BC%8C%E4%BC%9A%E6%9C%89%E6%84%8F%E6%83%B3%E4%B8%8D%E5%88%B0%E7%9A%84%E6%94%B6%E8%8E%B7&quot;&gt;用别人的语言交流，会有意想不到的收获&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/things-i-learnt-after-6-years-as-software-engineer/#%E7%90%86%E8%A7%A3%E5%89%8D%E4%BA%BA%E5%86%99%E7%9A%84%E3%80%8C%E7%83%82%E4%BB%A3%E7%A0%81%E3%80%8D&quot;&gt;理解前人写的「烂代码」&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/things-i-learnt-after-6-years-as-software-engineer/#%E5%9C%A8%E6%8A%80%E6%9C%AF%E5%92%8C%E5%B7%A5%E4%BD%9C%E4%B9%8B%E9%97%B4%E6%89%BE%E5%88%B0%E5%B9%B3%E8%A1%A1%E7%82%B9&quot;&gt;在技术和工作之间找到平衡点&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/nav&gt;&lt;h2 id=&quot;%E4%BF%9D%E6%8C%81%E4%B8%80%E9%A2%97%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E7%9A%84%E5%BF%83&quot; tabindex=&quot;-1&quot;&gt;保持一颗解决问题的心&lt;/h2&gt;
&lt;p&gt;按照我的观察，那些在工作中用技术取胜的人们共同点都在于他们能保持一颗解决问题的心。他们可以率先想到一种更优的手段解决存在的问题(一般是效率问题)。他们不是嗅觉特别灵敏或者技术特别强，而是当他们遇到了问题，不是把它作为抱怨的话题，而是开始思考这个问题为什么没人解决、应该怎么解决，然后把它实现出来。这种心态在职场上特别稀缺。&lt;/p&gt;
&lt;p&gt;我在创业公司的时候做一个图文排版的 App, 设计师会设计一些模板，然后交给我来实现。当时我们有很多模板，为了测试这些模板实现在不同的手机屏幕大小会有什么问题，我们要花特别多的精力。可以想象测试的数量 = 模板数量 * 屏幕尺寸的数量。后来我用 puppeteer 写了个自动生成不同屏幕和模板的截图，直接交给设计师一个一个地看。节省了大量的时间。这个事情没什么技术含量，但它解决了很重要的问题。&lt;/p&gt;
&lt;p&gt;工作中需要解决的问题不仅仅在代码上，也有可能出现在非技术问题上。工作中我特别喜欢和非技术同事聊天，了解他们的工作。因为我常常觉得影响项目前进的原因不一定出在我们用了不适合的技术或者不够「先进」的技术。了解非技术同事的工作流程让我大有收获，我会发现他们有一些工作是可以通过写一段程序把原本的工作量做到指数级的下降，而通常非技术同事是很难察觉到的。&lt;/p&gt;
&lt;p&gt;这样的例子特别多。有次我和一个运营同事聊天，我们当时在开发一个新闻内容的管理后台，他们常常用这个后台捞一些内容做分析。聊天的时候了解到他们有一部份的工作就是在上面按条件查询一些内容，再一条条地粘贴到 excel 里面，他说这常常要花一下午。后来我帮她做了一个一键导出成 excel 的功能。&lt;/p&gt;
&lt;p&gt;她觉得这很不可思议，但这在技术的角度来说太简单了。我也因此了解到，对于不是做技术的人来说，他们很难察觉到哪一些事情是可以用技术解决的，所以我们不能希望他们主动地提出一个需求，只能我们作为掌握技术的人主动地去了解他们。&lt;/p&gt;
&lt;p&gt;又一次我和我们的测试吃饭，聊到他们怎么做测试。我发现他们会用 mindmap 先梳理出来一些测试流程，然后一个个地做。但是痛点在于他们常常要手动维护一个文档列出这些 case 的测试结果，这些结果包括截屏，以及证明测试通过的请求返回信息等等。不但麻烦，还很难追踪。&lt;/p&gt;
&lt;p&gt;于是我做了一个小 demo Web App，他们可以直接上传他们做好的 Mindmap, 通过他们的 mindmap 直接生成出来 case item，在项目的开发环境页面代码里面，只要注入这个 case id，就可以在测试之前开始记录请求日志，结束之后会上传到这个平台，这样在这个平台就能直接看到每一个 case 操作的时候的整个过程的记录。这个小 demo 后来被用于花呗的大部份前端项目，当然听说现在已经做得和我当时做的小 demo 完全不同了。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BA%86%E8%A7%A3%E4%BD%A0%E7%9A%84%E7%94%A8%E6%88%B7&quot; tabindex=&quot;-1&quot;&gt;了解你的用户&lt;/h2&gt;
&lt;p&gt;我自认为自己还算是一个有那么一些产品思维的程序员，因为经常也会写一些自己的小产品。但在刚出来工作的时候，我在工作中太沉迷于技术本身。把心思都放在了诸如怎么重构，怎么改进构建速度之类的问题。我在阿里 P5 升 P6 的答辩中，我被问了一个我至今印象深刻的问题：你有了解你的用户是怎么用你在做的这个东西吗？&lt;/p&gt;
&lt;p&gt;这个问题是我从来没有想过的，我哑口无言。可能它只是一个晋升答辩问题模板中的一个问题，但对我来说这个问题让我清醒了许多。当时我们做的是内部用的新闻内容管理后台，这个后台的用户是一些小编。我们和这些小编有一个群，但基本是用来报 bug 的。我离这些用户这么近，却从来没有了解过他们的使用感受。我想，如果我当时找他们聊一聊，可能也会有意想不到的收获。或许他们会报怨这个后台的加载速度很慢，我们就可以着手解决加载速度的问题，而不是和同事纠结在用哪种前端状态管理库这种无聊事情上。用户并不关心我们用的是 MobX 还是 Redux.&lt;/p&gt;
&lt;h2 id=&quot;%E4%B8%8D%E8%A6%81%E6%8B%BF%E8%87%AA%E5%B7%B1%E7%9A%84%E5%B0%BA%E5%AD%90%E5%8E%BB%E5%BA%A6%E9%87%8F%E5%88%AB%E4%BA%BA&quot; tabindex=&quot;-1&quot;&gt;不要拿自己的尺子去度量别人&lt;/h2&gt;
&lt;p&gt;我刚出来工作犯的最大的错误之一就是拿自己的尺子去度量别人。我因为从小对编程痴迷，写程序对我来说是人生中最大的兴趣，我把几乎所有的时间都花在了技术上。当时我天真地认为所有程序员都应该像我这样，对待技术也应该有一种理想主义，我在互联网上结交的技术朋友都是这样的。所以我当时对我的同事特别苛刻，甚至对那些把写程序只当成工作的人嗤之以鼻。后来回想起来，这是非常错误的想法。每个人有每个人的追求，技术也只是多个兴趣爱好的其中一种。在当时别人的眼里我可能是个「怪人」，甚至有点「装逼」。&lt;/p&gt;
&lt;h2 id=&quot;%E4%BF%9D%E6%8C%81%E5%AD%A6%E4%B9%A0%E3%80%81be-open-mind&quot; tabindex=&quot;-1&quot;&gt;保持学习、be open-mind&lt;/h2&gt;
&lt;p&gt;我每天都会在 Twitter 和 Hackernews 发现很多最新的技术和技术思考，我关注了很多开源库的作者，我可以第一时间了解到他们最近在思考什么，在接触什么。这种主动接收会扩大你的眼界，让你在解决问题的时候有更广的思路。&lt;/p&gt;
&lt;p&gt;不要只关注自己的领域。我还关注了很多写 Rust, 写 Go, 写 iOS/Android 的人。学习主要是学习技术背后解决问题的方式，这些解决问题的方式说不准也能应用到你自己的领域。&lt;/p&gt;
&lt;p&gt;保持学习一直是和同行拉开差距最重要的一点。&lt;/p&gt;
&lt;h2 id=&quot;%E6%83%B3%E6%B8%85%E6%A5%9A%EF%BC%8C%E5%86%8D%E4%B8%8B%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81&quot; tabindex=&quot;-1&quot;&gt;想清楚，再下手写代码&lt;/h2&gt;
&lt;p&gt;我写代码的速度非常快，因为我已经花了超过十年的时间在写代码了。很多东西想实现，对我来说基本是纯粹的堆代码。导致我非常容易不经过多的思考就开始动手写。我为此吃了不少亏，常常写到一半发现一些没有想到过的问题，导致需要重新设计，重新改写。我的一位前老板很了解我，他也是个多年经验的程序员了。有一次我们在讨论一个新东西，他对我说，「不要着急，想清楚了再写」。这句话我一直记在心里。后来每次动手写代码之前，我都会把整个流程的设计先思考清楚，避免了很多不必要的重写。&lt;/p&gt;
&lt;h2 id=&quot;%E6%95%AC%E7%95%8F%E7%94%A8%E6%88%B7&quot; tabindex=&quot;-1&quot;&gt;敬畏用户&lt;/h2&gt;
&lt;p&gt;在写自己的一些没什么人用的开源库或者公司内部用的平台的时候，通常不需要过多思考就能把代码发布出去。到了做花呗这种用户基数庞大的产品，才意识到代码发布和以前所体验到的完全不同。&lt;/p&gt;
&lt;p&gt;蚂蚁金服有代码发布的「三板斧」，这是从入职培训到实际工作中就会被反复提及的 must-follow rule. 「三板斧」指的是「可灰度」、「可监控」、「可回滚」。在代码发布之前，要先想想自己的代码是不是符合这三个条件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你的代码发布之后，如果出了问题，是不是可以被监控到的？&lt;/li&gt;
&lt;li&gt;你的代码是不是可以灰度发布的，而不是一下子全量被推到线上的？&lt;/li&gt;
&lt;li&gt;代码发布以后，出了问题，是不是可以回滚的？如何回滚？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在经历了用户基数如此庞大的产品开发之后，我对代码发布变得尤为审慎。我记得有次只是单纯改了某段 HTML, 但我还是盯着这个 PR diff 看了几分钟，在想这个修改会不会导致什么问题。&lt;/p&gt;
&lt;p&gt;虽然蚂蚁的基础建设可以让这三板斧很容易实现(有成熟的发布平台进行灰度和回滚，有成熟的监控库)；虽然即使遵守了三板斧，还是会有 bug. 但是这种代码发布的思维模式是好的，即使我到了别的公司，我在代码发布前还是会问自己这三个问题。&lt;/p&gt;
&lt;h2 id=&quot;%E8%B7%A8%E5%9B%A2%E9%98%9F%E5%90%88%E4%BD%9C%E6%98%AF%E5%88%A9%E7%9B%8A%E4%BA%A4%E6%8D%A2&quot; tabindex=&quot;-1&quot;&gt;跨团队合作是利益交换&lt;/h2&gt;
&lt;p&gt;在大公司里，有时在做一个事情的时候，需要别的团队一起合作，或许是用到别的团队的接口、或许是需要别的团队开发新的接口，但这通常很难。我以前天真地以为，只要我们做的事情是有利于业务的，别的团队自然就应该一起合作。但实际上，大家更看中的是这个事情对自己的团队有什么好处。&lt;/p&gt;
&lt;p&gt;换位思考一下，我们和别的团队合作，对于他们来说，增加了工作量，增加了风险(带来更高的 qps, 写更多的代码会导致更多的维护成本)。决定是否合作，首先取决于这是否是自上而下的要求，其次就是合作对他们的 KPI 有没有好处。&lt;/p&gt;
&lt;p&gt;所以我学会了在游说别的团队合作的时候，首先应该想明白合作能给别人带来什么好处，而不是对事情本身夸夸其谈。这样更容易促成合作。&lt;/p&gt;
&lt;h2 id=&quot;%E7%94%A8%E5%88%AB%E4%BA%BA%E7%9A%84%E8%AF%AD%E8%A8%80%E4%BA%A4%E6%B5%81%EF%BC%8C%E4%BC%9A%E6%9C%89%E6%84%8F%E6%83%B3%E4%B8%8D%E5%88%B0%E7%9A%84%E6%94%B6%E8%8E%B7&quot; tabindex=&quot;-1&quot;&gt;用别人的语言交流，会有意想不到的收获&lt;/h2&gt;
&lt;p&gt;有研究发现如果你用别人的母语和他交流，他会更容易接受你的观点，对你也会更友好。我发现这个心理同样适用在技术交流中。作为一个前端程序员，在和后端程序员商量技术方案的时候，如果可以更多地使用后端的术语，从后端的角度反推前端的想法，他会更容易接受。&lt;/p&gt;
&lt;p&gt;我自己业余是个 full stack 程序员，所以很容易切换到别人的语境，也能从别人的角度去理解他的想法。因此沟通会更加顺畅。&lt;/p&gt;
&lt;h2 id=&quot;%E7%90%86%E8%A7%A3%E5%89%8D%E4%BA%BA%E5%86%99%E7%9A%84%E3%80%8C%E7%83%82%E4%BB%A3%E7%A0%81%E3%80%8D&quot; tabindex=&quot;-1&quot;&gt;理解前人写的「烂代码」&lt;/h2&gt;
&lt;p&gt;这里的「理解」不是指理解烂代码的逻辑，而是理解为什么会写成烂代码。我经常会听到同事报怨他看到的旧代码写得如何烂，但是实际上很多烂代码产生的原因不是因为技术不行，而是受限于技术的发展和业务的复杂性。随着自己写的代码越来越多，就越能理解这些「烂代码」的存在。看出来了烂代码，也不要着急去重构，这些代码很有可能藏着一些你不知道的特殊业务需求。如果你不需要碰这些代码，那就尽量别碰。&lt;/p&gt;
&lt;h2 id=&quot;%E5%9C%A8%E6%8A%80%E6%9C%AF%E5%92%8C%E5%B7%A5%E4%BD%9C%E4%B9%8B%E9%97%B4%E6%89%BE%E5%88%B0%E5%B9%B3%E8%A1%A1%E7%82%B9&quot; tabindex=&quot;-1&quot;&gt;在技术和工作之间找到平衡点&lt;/h2&gt;
&lt;p&gt;在刚出来工作的前几年，我特别陶醉在把自己学到的新东西试图用在工作中。我的想法是，只有我把这个技术用到实际的工作中，我才算学习了这个技术。&lt;/p&gt;
&lt;p&gt;其实这个想法是不对的，学习技术并不一定要求你把他用到工作中。工作就是工作，学习就是学习。工作的内容是为了业务服务的。我在创业公司工作的时候，曾经因为把一个我刚学习到的库用在业务中，因为一些我不知道的坑导致业务进度出了点问题。老板生气地说：业务不是你的试验田。&lt;/p&gt;
&lt;p&gt;我后来遇到很多「后辈」(我竟然也开始有后辈了) 请教我说觉得自己在工作中不能运用到自己平时学习的技术，因此觉得自己技术没什么长进。我认为这种想法不太正确。&lt;/p&gt;
&lt;p&gt;能把学习到的技术运用到自己的工作中当然是最好的，但这是可遇不可求的事。但是这不代表没有用在工作中，就等于没有真正学习到这个技术。我认为很多人对技术学习有错误的理解，对我来说，学习技术的精髓在于理解这个技术的 Why, What, How. 和能不能用到工作中没有太大的关系。&lt;/p&gt;
&lt;p&gt;举个例子，我在刚接触到 Redux 的时候，我去学习它，除了了解它怎么用以外，我特别关心的是，Redux 的哲学是什么？是什么启发了 Redux 的作者创造了 Redux? 他和别的库有什么不同？顺着这些问题，我就会了解更多的东西，比如我发现 Redux 是受了 Elm 的启发，我就会去了解 Elm -&amp;gt; 了解 Functional Programming -&amp;gt; 了解 Immutable, 然后关注 Dan (Redux 的作者) 的 Twitter, 看他日常会分享什么，看他对自己做的这个东西的理解是什么。即使我没有把 Redux 用在工作中(事实上我从来没有用过 Redux)，但我在学习这个库的时候，我学习到的不仅仅是 Redux 本身，还有它背后的更多东西。我可能很快就会忘掉 Redux 的 API, 但那又如何，那些它背后的知识才是最有价值的，是不会被忘掉的。&lt;/p&gt;
&lt;p&gt;而工作则相当于是一个真实的场景，是在你学习新的技术的时候，帮助你进行实际思考的场景。你需要有意识地去想，这个技术如果用到我的工作中，它是否适合？它能解决什么问题？它为什么适合？它为什么不适合。当你在学习新技术的时候，结合这个技术，多思考这些问题，这才是真正的学习。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>做这个世界的生产者</title>
    <link href="https://lutaonan.com/blog/be-a-creator/"/>
    <updated>2021-01-27T00:00:00Z</updated>
    <id>https://lutaonan.com/blog/be-a-creator/</id>
    <content type="html">&lt;p&gt;偶尔看到这篇名叫 &lt;a href=&quot;https://tjcx.me/p/consume-less-create-more&quot;&gt;Consume less, create more&lt;/a&gt; 的文章，是作者从「消费者」转变为「生产者」的心路历程。他每天在巴士上面用 iPhone 写点什么，最终写出了这篇文章。&lt;/p&gt;
&lt;p&gt;我从懂事开始就一直觉得自己在这个世界上与众不同，觉得自己的出生一定是背负了某个特殊的使命。后来发现原来每个人年轻的时候都是这么想的，随着年纪渐长，大多数人开始接受自己只是个普通人的事实。我也不例外。&lt;/p&gt;
&lt;p&gt;但唯一没有变过的是我没有因为意识到了自己的平凡而停止了试图变得不平凡。其中的一个表现就是我希望在这个世界上，我是作为一个生产者存在的，而不只是一个消费者。&lt;/p&gt;
&lt;p&gt;写博客、编程、做音乐都是我的生产，即使我写的博客没有让我成为几十万粉丝的 KOL, 我写的代码没有几万的 star, 唱的歌的观看数只是几百，我还是保持生产，&lt;strong&gt;因为对于这个世界，能让我有那么一点与众不同的是我的生产，而不是我的消费。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我讨厌抖音，不是因为它的内容，是因为它默默地把人驯化成了贪婪的信息消费者。如果我什么都不创造，那么我每天看 Hacker News 和别人每天刷抖音没有任何区别。&lt;/p&gt;
&lt;p&gt;这个世界的每个人都是消费者，但不是每个人都是生产者。如果你也希望为这个世界留下点什么，就去创造，别担心你创造的是不是垃圾，只要创造了，是一定会有收获的。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>国内自建图床指南</title>
    <link href="https://lutaonan.com/blog/aliyun-cdn-tutorial/"/>
    <updated>2020-03-07T00:00:00Z</updated>
    <id>https://lutaonan.com/blog/aliyun-cdn-tutorial/</id>
    <content type="html">&lt;nav class=&quot;table-of-contents&quot;&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/aliyun-cdn-tutorial/#%E6%9C%AC%E6%96%87%E7%9A%84%E7%9B%AE%E6%A0%87%E8%AF%BB%E8%80%85&quot;&gt;本文的目标读者&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/aliyun-cdn-tutorial/#%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%81%9A%E5%9B%BE%E5%BA%8A%E7%9A%84%E5%8E%9F%E7%90%86&quot;&gt;云服务做图床的原理&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/aliyun-cdn-tutorial/#%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3&quot;&gt;步骤详解&lt;/a&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/aliyun-cdn-tutorial/#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-oss-bucket&quot;&gt;创建一个 OSS Bucket&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/aliyun-cdn-tutorial/#%E5%88%9B%E5%BB%BA-cdn-%E9%85%8D%E7%BD%AE&quot;&gt;创建 CDN 配置&lt;/a&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/aliyun-cdn-tutorial/#%E8%AE%BE%E7%BD%AE%E5%9F%9F%E5%90%8D%E7%9A%84-cname&quot;&gt;设置域名的 CNAME&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/aliyun-cdn-tutorial/#%E5%BC%80%E5%90%AF-https&quot;&gt;开启 HTTPS&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/aliyun-cdn-tutorial/#%E5%BC%80%E5%90%AF%E7%A7%81%E6%9C%89-bucket-%E5%9B%9E%E6%BA%90&quot;&gt;开启私有 Bucket 回源&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/aliyun-cdn-tutorial/#%E9%85%8D%E7%BD%AE-refer-%E9%98%B2%E7%9B%97%E9%93%BE&quot;&gt;配置 Refer 防盗链&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/aliyun-cdn-tutorial/#%E4%BD%BF%E7%94%A8-upic-%E6%96%B9%E4%BE%BF%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87&quot;&gt;使用 uPic 方便上传图片&lt;/a&gt;&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/aliyun-cdn-tutorial/#%E9%85%8D%E7%BD%AE-upic&quot;&gt;配置 uPic&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/aliyun-cdn-tutorial/#%E6%88%91%E5%8D%9A%E5%AE%A2%E7%9A%84-cdn-%E7%94%A8%E9%87%8F&quot;&gt;我博客的 CDN 用量&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lutaonan.com/blog/aliyun-cdn-tutorial/#%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5&quot;&gt;相关链接&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/nav&gt;&lt;p&gt;我的博客很长一段时间在使用新浪微博作为图床，自从新浪微博开始防外链，我博客文章很多配图丢失了。我意识到我需要一个稳定可靠的图床，所以开始用阿里云自建一个我自己的图床，目前已经稳定使用了大半年。&lt;/p&gt;
&lt;p&gt;我起初以为很难，而且费用不底。但是在这半年，我每个月的 CDN 费用不高（当然这也取决于访问量）。我自诩自己的博客不至于荒废或者没什么人访问，所以对于那些和我的博客规模差不多的独立博客博主，本篇应该算得上是一个十分贴切的参考。&lt;/p&gt;
&lt;p&gt;当然，虽然我用的是阿里云，但套用到其它云服务都是一样的，读者可以读完后价比三家再作选择。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;声明：本文和阿里云没有任何利益关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;%E6%9C%AC%E6%96%87%E7%9A%84%E7%9B%AE%E6%A0%87%E8%AF%BB%E8%80%85&quot; tabindex=&quot;-1&quot;&gt;本文的目标读者&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;有自建图床的需求，且对国内访问速度有要求的。例如独立博客、独立摄影站，甚至独立播客主于用存放音频文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%81%9A%E5%9B%BE%E5%BA%8A%E7%9A%84%E5%8E%9F%E7%90%86&quot; tabindex=&quot;-1&quot;&gt;云服务做图床的原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/uPic/Untitled%20%28Draft%29-1%206.jpg?x-oss-process=style/80&quot; alt=&quot;原理图&quot; /&gt;&lt;/p&gt;
&lt;p&gt;云服务产品有很多，搭建图床只需要关注 OSS 和 CDN. OSS 是对象存储服务，通俗来说就是用来存文件的。OSS 都有对应的域名，文件保存在 OSS 后，可以通过 URL 下载它。&lt;/p&gt;
&lt;p&gt;但是直接通过 OSS 下载的成本很高，价格十分昂贵，所以我们需要 CDN 来分发，节约成本。在阿里云，可以把 CDN 绑定到 OSS, 通过 CDN 去访问这个文件时，如果是首次访问，CDN 会从 OSS 取得这个文件，这个过程叫「回源」。之后再访问会直接从 CDN 读取。&lt;/p&gt;
&lt;h2 id=&quot;%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3&quot; tabindex=&quot;-1&quot;&gt;步骤详解&lt;/h2&gt;
&lt;p&gt;因为我自己用的是阿里云，所以以阿里云为例（假设你已经注册好帐号）。&lt;/p&gt;
&lt;h3 id=&quot;%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA-oss-bucket&quot; tabindex=&quot;-1&quot;&gt;创建一个 OSS Bucket&lt;/h3&gt;
&lt;p&gt;一个 Bucket 相当于 OSS 中的一个存储空间，在 &lt;a href=&quot;https://oss.console.aliyun.com/overview&quot;&gt;OSS 控制台&lt;/a&gt; 点击创建 Bucket:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/uPic/%E6%88%AA%E5%B1%8F2020-03-07%E4%B8%8B%E5%8D%884.30.25.png?x-oss-process=style/80&quot; alt=&quot;创建 Bucket&quot; /&gt;&lt;/p&gt;
&lt;p&gt;填好 Bucket 名称和区域，其它选项按照默认即可。&lt;/p&gt;
&lt;p&gt;创建成功后，在 Bucket 的文件管理可以上传文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/uPic/B2l6dV.png?x-oss-process=style/80&quot; alt=&quot;上传文件&quot; /&gt;&lt;/p&gt;
&lt;p&gt;查看上传文件的信息，你可以看到文件有 URL, 但由于在创建 Bucket 的时候，为了防止盗用，我们选的 Bucket 权限为私有，所以从 URL 其实无法访问这个文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/uPic/HUFU2y.png?x-oss-process=style/80&quot; alt=&quot;文件详情&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E5%88%9B%E5%BB%BA-cdn-%E9%85%8D%E7%BD%AE&quot; tabindex=&quot;-1&quot;&gt;创建 CDN 配置&lt;/h3&gt;
&lt;p&gt;在 &lt;a href=&quot;https://cdn.console.aliyun.com/&quot;&gt;CDN 控制台&lt;/a&gt; 进入域名管理，就可以开始配置 CDN 域名。&lt;/p&gt;
&lt;p&gt;所以，在创建 CDN 前，你需要买一个域名。这个域名可以随便买个便宜的不主流的，因为没人在意一个图床的域名。&lt;/p&gt;
&lt;p&gt;创建域名后，有一个要注意的地方，就是如果你需要国内加速，你的域名必须备案。备案其实是整个自建图床成本最高的一个环节。如果你的博客或者网站域名已经备案，那么可以直接用这个域名分配一个二级域名给 CDN 用。省去再备案的麻烦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/uPic/guk3mO.png?x-oss-process=style/80&quot; alt=&quot;添加域名&quot; /&gt;&lt;/p&gt;
&lt;p&gt;比如你的域名是 &lt;a href=&quot;http://blabla.com/&quot;&gt;blabla.com&lt;/a&gt;, 那么你的加速域名可以是 &lt;a href=&quot;http://static.blabla.com/&quot;&gt;static.blabla.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;源站信息选「OSS 域名」，选中之后会出现一个下拉选择，可以选中刚刚创建的 Bucket 源站：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/uPic/GPlUFe.png?x-oss-process=style/80&quot; alt=&quot;源站域名&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果你的网站用 https, 端口选 443.&lt;/p&gt;
&lt;p&gt;如果你域名已经备案，就选全球或中国大陆。&lt;/p&gt;
&lt;h4 id=&quot;%E8%AE%BE%E7%BD%AE%E5%9F%9F%E5%90%8D%E7%9A%84-cname&quot; tabindex=&quot;-1&quot;&gt;设置域名的 CNAME&lt;/h4&gt;
&lt;p&gt;创建完后，你需要把你域名的 CNAME 指定为提供的值。如果你域名解析也是用阿里云，可以查看 &lt;a href=&quot;https://help.aliyun.com/document_detail/27144.html?spm=5176.11785003.0.0.6402142fn9IEPG&quot;&gt;这篇文档&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/uPic/j5Vvuk.png?x-oss-process=style/80&quot; alt=&quot;CNAME&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E5%BC%80%E5%90%AF-https&quot; tabindex=&quot;-1&quot;&gt;开启 HTTPS&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/uPic/TezAat.png?x-oss-process=style/80&quot; alt=&quot;https&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E5%BC%80%E5%90%AF%E7%A7%81%E6%9C%89-bucket-%E5%9B%9E%E6%BA%90&quot; tabindex=&quot;-1&quot;&gt;开启私有 Bucket 回源&lt;/h3&gt;
&lt;p&gt;因为前面在创建 Bucket 的时候权限设置为私有，所以需要给 CDN 开启私有 Bucket 回源的权限。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/uPic/G0K6M4.png?x-oss-process=style/80&quot; alt=&quot;私有Bucket回源&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E9%85%8D%E7%BD%AE-refer-%E9%98%B2%E7%9B%97%E9%93%BE&quot; tabindex=&quot;-1&quot;&gt;配置 Refer 防盗链&lt;/h3&gt;
&lt;p&gt;CDN 防盗是有必要的，如果你的图片被别处盗用，会增加不必要的流量。所以推荐设置 Refer 防盗白名单，只对允许指定的域名访问。例如我设置了除了我自己博客以外的一些 RSS Reader 以及 V2EX 可以访问：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/uPic/ZST89j.png?x-oss-process=style/80&quot; alt=&quot;Refer 防盗链&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E4%BD%BF%E7%94%A8-upic-%E6%96%B9%E4%BE%BF%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87&quot; tabindex=&quot;-1&quot;&gt;使用 uPic 方便上传图片&lt;/h2&gt;
&lt;p&gt;以上的准备都做完后，你已经拥有了一个图床。现在就需要一个方便的工具把图片上传到图床。如果你用 macOS, 我推荐开源的 &lt;a href=&quot;https://github.com/gee1k/uPic&quot;&gt;uPic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/uPic/cqSMIR.gif&quot; alt=&quot;upic&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E9%85%8D%E7%BD%AE-upic&quot; tabindex=&quot;-1&quot;&gt;配置 uPic&lt;/h3&gt;
&lt;p&gt;添加阿里云 OSS 配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/uPic/AisKxQ.png?x-oss-process=style/80&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这里需要填 AccessKey 和 SecretKey：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/uPic/VkPsCc.png?x-oss-process=style/80&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;你可以在 &lt;a href=&quot;https://ram.console.aliyun.com/users&quot;&gt;RAM 控制台&lt;/a&gt; 创建一个用户，然后创建 AccessKey.&lt;/p&gt;
&lt;p&gt;创建后给这个 AccessKey 授 AliyunOSSFullAccess 这个权限：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/uPic/m3KaPP.png?x-oss-process=style/80&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;%E6%88%91%E5%8D%9A%E5%AE%A2%E7%9A%84-cdn-%E7%94%A8%E9%87%8F&quot; tabindex=&quot;-1&quot;&gt;我博客的 CDN 用量&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/uPic/Pit7QZ.png?x-oss-process=style/80&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;从 2019 年 10 月 1 号至 2020 年 3 月 7 号总计 11.28GB. 按流量计费，每 GB 0.24 元，也才几块钱。&lt;/p&gt;
&lt;h1 id=&quot;%E7%9B%B8%E5%85%B3%E9%93%BE%E6%8E%A5&quot; tabindex=&quot;-1&quot;&gt;相关链接&lt;/h1&gt;
&lt;p&gt;如果你觉得本指南受用，可以通过 &lt;a href=&quot;https://www.aliyun.com/minisite/goods?userCode=n7qobwbd&quot;&gt;此链接&lt;/a&gt; 注册阿里云。&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>未来属于声明式编程</title>
    <link href="https://lutaonan.com/blog/declarative-programming-is-the-future/"/>
    <updated>2019-07-18T00:00:00Z</updated>
    <id>https://lutaonan.com/blog/declarative-programming-is-the-future/</id>
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E5%AE%A3%E5%91%8A%E5%BC%8F%E7%B7%A8%E7%A8%8B?oldformat=true&quot;&gt;声明式编程&lt;/a&gt; （Declarative Programming）是一种编程范式。现实世界中，我们大部分编码都是命令式的。&lt;/p&gt;
&lt;p&gt;举个最常见的例子，对于用 JavaScript 来构建 UI, React 是声明式的。&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// 普通的 DOM API 构建 UI&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; div &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;div&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; p &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; document&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;createElement&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;p&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;p&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;textContent &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;hello world&#39;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;UI&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; div&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;p&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// React 构建 UI&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; h &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; React&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;craeteElement&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token constant&quot;&gt;UI&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;div&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;p&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;hello world&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有的 DSL (HTML, XML, SQL) 都是声明式的，你写出一条 SQL 语句，只是为了告诉数据库你要什么，然后数据库就会给你对应的数据，而不是通过数据库的 API 去取。&lt;/p&gt;
&lt;pre class=&quot;language-sql&quot;&gt;&lt;code class=&quot;language-sql&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;SELECT&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;FROM&lt;/span&gt; Products &lt;span class=&quot;token keyword&quot;&gt;WHERE&lt;/span&gt; name&lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;Alipay&#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Apple 在今年 (2019 年) 也推出了 Swift UI, 在 WWDC 的 Swift UI 相关的 Session 里也&lt;a href=&quot;https://developer.apple.com/videos/play/wwdc2019/216/&quot;&gt;多次提到声明式 UI 开发的威力&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;声明式编程的潜力在于：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解放人力成本，你只要「声明」你要做什么，具体怎么做，由运行时解决。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数式编程就是声明式编程的一种，在函数式编程里的&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%B0%BE%E8%B0%83%E7%94%A8?oldformat=true&quot;&gt;尾递归&lt;/a&gt;性能，就取决于运行时，而不是靠程序员去手动优化。React 里你只要描述你的 UI, 接下来状态变化后 UI 如何更新，是 React 在运行时帮你处理的，而不是靠程序员优化 diff 算法。&lt;/p&gt;
&lt;p&gt;我们可以认为 Serverless (尤其是函数计算) 在运维领域获得了声明式的好处 —— 我们定义好了函数，我们只要告诉平台我们需要调用这个函数，那么如何进行计算资源分配、如何对代码做分布式部署，都不需要程序员考虑。&lt;/p&gt;
&lt;p&gt;运行时帮你完成工作，除了可以节省人力成本外，还降低了程序员出错的概率 —— 因为写的代码越少，出错的概率就越小。人是最不可靠的，我们应该尽量把工作交给计算机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「声明」是「描述」而不是真正「执行」&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在纯函数式编程语言里面，一切都是声明式的，是纯 (Pure) 的，没有副作用（Side Effect）的。&lt;/p&gt;
&lt;p&gt;Haskell 是一个纯函数式的语言，像在控制台输出文本这种方法（&lt;code&gt;putStrLn&lt;/code&gt;）就是一种副作用。在 Haskell 里 &lt;code&gt;putStrLn &amp;quot;Hello World&amp;quot;&lt;/code&gt; 本身不会真正地输出 “Hello World“, 而是返回一个 IO 类型，来说明他是一个副作用。但它如何被执行，取决于运行时。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://elm-lang.org/&quot;&gt;Elm&lt;/a&gt; 和 Haskell 一样，副作用也只是返回一种类似 Haskell 中的 IO 类型。在 Elm 中叫做 Cmd.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gbstatic.djyde.com/F5AF0D75-30A2-46DD-B66F-9FDEFFC10B27.png?x-oss-process=style/80&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;以上说的这些，可能太过抽象。所以我用前端的同学们应该都知道的 redux-saga 对此作更具象的解释。也可以解答为什么我虽然不喜欢 Redux, 但认为 redux-saga 是一个的很不错的库。因为他利用 redux 的 middleware 机制和 generator 巧妙地实现了类似 Haskell 的 IO.&lt;/p&gt;
&lt;p&gt;下面我将用 &lt;a href=&quot;https://redux-saga.js.org/docs/basics/DeclarativeEffects.html&quot;&gt;官方文档的例子&lt;/a&gt; 做解释。&lt;/p&gt;
&lt;p&gt;比如，以下是一个有副作用的函数:&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; call &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;redux-saga/effects&#39;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fetchProducts&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; products &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Api&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;fetch&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;/products&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;显然，&lt;code&gt;Api.fetch()&lt;/code&gt; 是副作用，它会发送网络请求。但是，在 redux-saga 里面，你不应该直接执行这个函数，而是使用 &lt;code&gt;call&lt;/code&gt; 告诉 redux-saga —— 你要执行 &lt;code&gt;Api.fetch&lt;/code&gt; , 参数为 &lt;code&gt;/products&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;所以，事实上这个函数没有被命令式地被执行，而是由 redux-saga 决定如何执行。&lt;/p&gt;
&lt;p&gt;如果你在外部直接调用 &lt;code&gt;fetchProducts()&lt;/code&gt;, 你会得到一个 Generator Iterator. 然后通过 &lt;code&gt;next()&lt;/code&gt; 得到你 yield 的值。所以你可以这样去测试你的程序：&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; iterator &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fetchProducts&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// expects a call instruction&lt;/span&gt;&lt;br /&gt;assert&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;deepEqual&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;br /&gt;  iterator&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;value&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token function&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;Api&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;fetch&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;/products&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token string&quot;&gt;&quot;fetchProducts should yield an Effect call(Api.fetch, &#39;./products&#39;)&quot;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是说，你要测试的是「你有没有告诉程序你要执行的副作用，以及执行的参数是什么」。和命令式编程不同，因为命令式的程序在你执行函数时会真实地执行这个 &lt;code&gt;Api.fetch&lt;/code&gt;，你必须用测试框架里类似 &lt;code&gt;mockFn&lt;/code&gt; 的手段去 mock 这个函数进行测试。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fetchProducts()&lt;/code&gt; 只有在 Redux 环境里，才会真正地执行副作用（在这里就是 Api.fetch 发送的网络请求）。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;声明式的编程是非常易于测试的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可视化编程是一种声明式编程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们探索可视化编程，是因为我们一直期望通过拖拽就能完成开发，其实就是期望我们完成任务仅仅需要通过声明，而不是写命令式的代码。当然这是一种理想的状态。&lt;/p&gt;
&lt;p&gt;DSL 是最常见的声明式编程形式。我一直在布道 GraphQL, 因为它把网络请求变得声明式了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;query {
	posts {
		id, title, content
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把网络请求变成声明式的好处有很多，其中一个就是它可以被放到各种各样的环境被执行。想象一下，我们可以打造一个可视化的应用搭建工具，在命令式编程的场景下，我们如果要做出如「点击按钮发送请求，得到响应后触发另一个 UI 更新」，就需要编写命令式的代码：&lt;/p&gt;
&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;onClickButton&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;	&lt;span class=&quot;token comment&quot;&gt;// 手动发送请求&lt;/span&gt;&lt;br /&gt;	&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fetch&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;/api&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;	&lt;span class=&quot;token comment&quot;&gt;// 手动更新 UI&lt;/span&gt;&lt;br /&gt;  table&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;dataSource &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; result&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果是 GraphQL, 我们可以把每一条 GraphQL 语句单独看作一个对象，他可以被任何组件触发，它的结果也可以被任何组件订阅。这样一来，在可视化的搭建工具里，程序员要做的是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;（声明式地）编写 GraphQL 查询语句&lt;/li&gt;
&lt;li&gt;（声明式地）为组件（比如某个按钮）绑定 onClick 事件为触发某条查询语句&lt;/li&gt;
&lt;li&gt;（声明式地）为组件（比如某个表格）绑定某条查询语句的响应值对应哪些组件的属性值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然现实世界的应用不是那么简单，但已经是跨出了很大一步。&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot; tabindex=&quot;-1&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;未来为什么属于声明式编程，因为我们在不断地努力提高开发效率，声明式编程显然是提效的最佳手段。React, Flutter, SwiftUI, GraphQL 的出现是最好的证明。最近听到内网太多人在提 Serverless, 我想说，&lt;strong&gt;提升开发效率，我们应该去想如何尽量让开发者声明式地编写代码，而不是只去想我们在 Serverless 上能做什么。&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>为你写的一首诗</title>
    <link href="https://lutaonan.com/blog/a-poem-for-you/"/>
    <updated>2019-06-12T00:00:00Z</updated>
    <id>https://lutaonan.com/blog/a-poem-for-you/</id>
    <content type="html">&lt;p&gt;我喜欢你&lt;/p&gt;
&lt;p&gt;从那年的某天&lt;/p&gt;
&lt;p&gt;我突然遇到你&lt;/p&gt;
&lt;p&gt;但他们说&lt;/p&gt;
&lt;p&gt;不要谈论你&lt;/p&gt;
&lt;p&gt;因为她不喜欢你&lt;/p&gt;
&lt;p&gt;所以你是禁忌 你是克星&lt;/p&gt;
&lt;p&gt;你只会带来麻烦&lt;/p&gt;
&lt;p&gt;他们请我不要谈论你&lt;/p&gt;
&lt;p&gt;我说你没有错 喜欢你也没有错&lt;/p&gt;
&lt;p&gt;错在她不喜欢你&lt;/p&gt;
&lt;p&gt;他们劝我私奔吧&lt;/p&gt;
&lt;p&gt;去一个大家都喜欢你的地方&lt;/p&gt;
&lt;p&gt;但她是我妈妈&lt;/p&gt;
&lt;p&gt;我如何离开她&lt;/p&gt;
&lt;p&gt;他们劝我离开你吧&lt;/p&gt;
&lt;p&gt;即使没有你 生活如常&lt;/p&gt;
&lt;p&gt;多年后&lt;/p&gt;
&lt;p&gt;我偶尔提起你&lt;/p&gt;
&lt;p&gt;他们请我不要谈论你&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>我在学校学到的东西</title>
    <link href="https://lutaonan.com/blog/things-i-learnt-at-school/"/>
    <updated>2018-10-04T00:00:00Z</updated>
    <id>https://lutaonan.com/blog/things-i-learnt-at-school/</id>
    <content type="html">&lt;p&gt;今年身边的朋友陆陆续续毕业出来工作了，偶尔有机会的时候会聚在一起聊聊，然后谈到各自的就业情况。我发现有很多朋友还不知道自己想从事的职业是什么，因此也不知道自己未来会怎么样，先做着现在能做的。&lt;/p&gt;
&lt;p&gt;因为我的经历特殊，有人也会对我开玩笑说真不知道读书有什么用，还不如早点出来工作。我知道以我朋友的受教育程度来说，这肯定只是玩笑，他们不可能是「读书无用论」者，所以我也会附和着笑。&lt;/p&gt;
&lt;p&gt;虽然这只是句玩笑话，但是确实令我回顾了一下我从我的在校生涯中得到了什么东西。&lt;/p&gt;
&lt;p&gt;我首先想到的是英语。我的小学是从一年级开始就有英语的课程，所以我接触英语的时间很早。我自认小学四年级以前我还是个很乖的学生，上课认真听讲，作业按时完成。所以我的语数英成绩都很不错。从小培养了「语感」，使得我一直以来可以低障碍地读写英文。这对我的编程学习、职业生涯都有很大的意义。懂英文让我可以亲自融入整个开源社区、技术社区，可以直接在 YouTube 听别人在 Conference 的 Talks, 吸取别人的思想。而不是等别人翻译过来。我认为能低障碍地读写英语是技术人成长很重要的条件。&lt;/p&gt;
&lt;p&gt;尽管我对现阶段的英语教育方式仍然存疑，我还是认为在基础教育里，英语是必不可少的。&lt;/p&gt;
&lt;p&gt;我的价值观和人生观，是我于在校生涯之中建立的。不过不要误会，这些都不是学校的课程直接赋予我的，而是&lt;strong&gt;学校这个「象牙塔」，让我可以有充分的时间去读书、学习和思考&lt;/strong&gt;。我虽然在班上是「差生」，但我敢说我是最爱学习和读书的。这句话要是被我当年的老师看到，估计他要笑个半死，但这是事实，不可否认。我在学校不用供车供房工作赚钱，我可以把一整天的时间花在读书上，&lt;strong&gt;我在我读的所有书里懂得了我应该成为一个什么样的人&lt;/strong&gt;、我应该努力让自己拥有什么样的品格才能算是一个「好人」。&lt;/p&gt;
&lt;p&gt;另外，我很多技术书籍都是在学校读的，比如《JavaScript 高级程序设计》，我读了很多遍。不是我自己想读那么多遍，而是当时我带回学校的就只有这一本书，我一个月才回家一次。那一个月我只能天天都读他。这本书我每读一遍都有新的发现。&lt;/p&gt;
&lt;p&gt;出来工作以后我还能像这样把一本好书读这么多遍又读这么认真吗？可以，但是很难了。&lt;/p&gt;
&lt;p&gt;我高中的时候，最喜欢上语文课。语文课本选的文章其实挺好的，比如说有《棋王》，以及很多《古文观止》里面的文言散文。偶尔发个新试卷，我也很开心，因为一张语文试卷有两篇阅读理解。我高中读的很多书，都是在试卷里和练习册里发现的，新的练习册一发下来，我就把所有的阅读理解都看一遍，看到哪篇我觉得不错的，我就看是节选哪本书，然后就去图书馆借回来。另外，写作文大概是我在学校里唯一的思考输出的方式了，因此我很珍惜每次写作文的机会，我把自己的所思所想全写进文章，以至于每次都很低分，因为离题万里。我的语文老师对我很包容，他知道我想什么，我很感谢他。&lt;/p&gt;
&lt;p&gt;有人会说，你把学校说得那么好，你自己怎么就辍学了呢。&lt;/p&gt;
&lt;p&gt;我认为，一个人在结束学校生涯以前，必须先弄清楚两个问题。一个是，**在离开学校以后，你在社会上是以一个什么样的角色存在？**另一个是，**你是否已经为迎接这个角色做好了充分准备？**学校的意义就是给你时间想清楚问题一，然后给你条件完成问题二。&lt;/p&gt;
&lt;p&gt;我在学校里，早已弄明白了这两个终极问题。我在社会上，将会以软件工程师的角色存在，并且我已经有能力胜任这个职位。往小的说，我能为我所在的公司创造价值，往大的说，我要为整个社区作出贡献。所以（在一所不怎么样的）大学对我来说已经不那么重要了，我希望早点投身社会创造价值。&lt;/p&gt;
&lt;p&gt;很多人就是因为在学校的时候从来不思考这两个问题，所以是「光着身」离开学校的。你是想创造价值，还是想做着不喜欢的工作然后满足于 &lt;a href=&quot;https://wiki.mbalib.com/wiki/%E5%A5%B6%E5%A4%B4%E4%B9%90%E7%90%86%E8%AE%BA&quot;&gt;奶头乐&lt;/a&gt; ，其实都由你自己决定。&lt;/p&gt;
&lt;p&gt;以上，就是我在学校学到的东西。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延伸阅读&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/37e022fa5f34&quot;&gt;《科学的方法， 公正的态度，果断的决心》--- 竺可桢&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
</feed>